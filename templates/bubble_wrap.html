{% extends "base.html" %}

{% block content %}
<div class="container py-5">
    <div class="row justify-content-center">
        <div class="col-lg-8">
            <div class="card shadow-sm border-0">
                <div class="card-header bg-white py-3">
                    <div class="d-flex justify-content-between align-items-center">
                        <h1 class="h3 mb-0">Bubble Wrap Popper</h1>
                        <a href="{{ url_for('games') }}" class="btn btn-outline-secondary btn-sm">
                            <i class="bi bi-arrow-left me-1"></i> Back to Games
                        </a>
                    </div>
                </div>
                <div class="card-body p-4">
                    <div class="text-center mb-4">
                        <p class="lead">Pop the bubbles to relieve stress! Click or tap to pop.</p>
                        <div class="d-flex justify-content-center align-items-center mb-3">
                            <div class="me-3">
                                <span class="badge bg-primary">Popped: <span id="popped">0</span></span>
                            </div>
                            <div>
                                <button id="reset-btn" class="btn btn-sm btn-outline-secondary">
                                    <i class="bi bi-arrow-clockwise"></i> Reset
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <div id="bubble-wrap" class="bubble-wrap">
                        <!-- Bubbles will be generated by JavaScript -->
                    </div>
                    
                    <div class="mt-4 text-center">
                        <button id="new-sheet" class="btn btn-primary">
                            <i class="bi bi-plus-circle me-1"></i> New Sheet
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Audio context will be created in JavaScript -->

<style>
.bubble-wrap {
    display: grid;
    grid-template-columns: repeat(10, 1fr);
    gap: 10px;
    padding: 15px;
    background-color: #f8f9fa;
    border-radius: 8px;
    touch-action: manipulation;
    max-width: 100%;
    margin: 0 auto;
    justify-content: center;
}

.bubble {
    aspect-ratio: 1;
    background-color: #4a6cf7;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease;
    position: relative;
    overflow: hidden;
    box-shadow: inset 0 -3px 5px rgba(0,0,0,0.2);
}

.bubble::after {
    content: '';
    position: absolute;
    width: 30%;
    height: 30%;
    background-color: rgba(255,255,255,0.7);
    border-radius: 50%;
    top: 15%;
    left: 15%;
}

.bubble.popped {
    transform: scale(0.8);
    opacity: 0.5;
    background-color: #e9ecef;
    pointer-events: none;
}

.bubble:active:not(.popped) {
    transform: scale(0.95);
}

@keyframes pop {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(0.8); }
}
</style>
{% endblock %}

{% block extra_js %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    const bubbleWrap = document.getElementById('bubble-wrap');
    const poppedCount = document.getElementById('popped');
    const resetBtn = document.getElementById('reset-btn');
    const newSheetBtn = document.getElementById('new-sheet');
    
    // Audio context and gain node variables
    let audioContext;
    let gainNode;
    
    // Initialize audio context on first interaction
    function initAudio() {
        if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            gainNode = audioContext.createGain();
            gainNode.gain.value = 0.4; // Slightly reduced volume
            gainNode.connect(audioContext.destination);
            
            // Resume audio context if it was suspended
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }
        return audioContext;
    }
    
    // Generate realistic bubble wrap pop sound
    function playClickSound() {
        if (!audioContext) initAudio();
        
        const now = audioContext.currentTime;
        
        // Create multiple layers for a richer pop sound
        const popLayers = [];
        
        // Main pop with slight variations in timing and volume
        popLayers.push(createBubblePopLayer(now, 1.0, 0));
        popLayers.push(createBubblePopLayer(now, 0.6, 0.01));
        popLayers.push(createBubblePopLayer(now, 0.4, 0.02));
        
        // Add a high-frequency click for more pop (higher pitch)
        const click = audioContext.createOscillator();
        const clickGain = audioContext.createGain();
        click.type = 'sine';
        click.frequency.setValueAtTime(5000, now); // Higher initial frequency
        click.frequency.exponentialRampToValueAtTime(1500, now + 0.0015); // Faster drop
        clickGain.gain.setValueAtTime(0.5, now); // Slightly louder
        clickGain.gain.exponentialRampToValueAtTime(0.001, now + 0.003); // Quicker decay
        click.connect(clickGain);
        click.start(now);
        click.stop(now + 0.008); // Shorter duration
        
        // Create a merger for the final output
        const merger = audioContext.createChannelMerger(2);
        
        // Connect all layers to output
        popLayers.forEach(layer => {
            layer.connect(merger, 0, 0);
            layer.connect(merger, 0, 1);
        });
        clickGain.connect(merger, 0, 0);
        clickGain.connect(merger, 0, 1);
        
        // Add a high-pass filter to emphasize higher frequencies
        const highPass = audioContext.createBiquadFilter();
        highPass.type = 'highpass';
        highPass.frequency.value = 500; // Higher cutoff for more treble
        
        // Connect to output with some gain
        const finalGain = audioContext.createGain();
        finalGain.gain.value = 0.8;
        
        merger.connect(highPass).connect(finalGain).connect(gainNode);
        
        // Clean up
        setTimeout(() => {
            popLayers.forEach(layer => layer.disconnect());
            merger.disconnect();
            highPass.disconnect();
            finalGain.disconnect();
            click.disconnect();
            clickGain.disconnect();
        }, 300);
    }
    
    // Create a single layer of bubble pop sound
    function createBubblePopLayer(now, volume = 1.0, delay = 0) {
        const nowWithDelay = now + delay;
        
        // Random size variation (affects pitch and timing)
        const size = 0.6 + Math.random() * 0.8; // 0.6 to 1.4
        
        // Create oscillators for the pop sound
        const popOsc1 = audioContext.createOscillator();
        const popOsc2 = audioContext.createOscillator();
        const popEnv = audioContext.createGain();
        
        // Base frequency based on bubble size (smaller = higher pitch)
        const baseFreq = 300 + (1 - size) * 1200; // 300-1500Hz based on size (higher range)
        
        // Configure pop oscillators with higher frequencies and more pronounced attack
        popOsc1.type = 'sine';
        popOsc1.frequency.setValueAtTime(baseFreq * 4.0, nowWithDelay); // Higher initial frequency
        popOsc1.frequency.exponentialRampToValueAtTime(baseFreq * 1.0, nowWithDelay + 0.015); // Faster drop
        
        popOsc2.type = 'triangle';
        popOsc2.frequency.setValueAtTime(baseFreq * 2.0, nowWithDelay); // Higher frequency
        popOsc2.frequency.exponentialRampToValueAtTime(baseFreq * 0.7, nowWithDelay + 0.03); // Slightly higher base
        
        // Pop envelope - faster attack, more pronounced decay
        popEnv.gain.setValueAtTime(0.001, nowWithDelay);
        popEnv.gain.linearRampToValueAtTime(0.6 * volume, nowWithDelay + 0.001);
        popEnv.gain.exponentialRampToValueAtTime(0.001, nowWithDelay + 0.08 * size);
        
        // Create noise for the burst - more pronounced
        const noise = audioContext.createBufferSource();
        const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.08, audioContext.sampleRate);
        const noiseData = noiseBuffer.getChannelData(0);
        
        // Fill noise buffer with random values - more aggressive noise
        for (let i = 0; i < noiseData.length; i++) {
            noiseData[i] = (Math.random() * 2 - 1) * 0.5 * volume;
        }
        
        // Noise processing with higher frequency emphasis
        const noiseFilter = audioContext.createBiquadFilter();
        noiseFilter.type = 'bandpass';
        noiseFilter.frequency.value = 2500 + Math.random() * 6000; // 2500-8500Hz (higher range)
        noiseFilter.Q.value = 2.5 + Math.random() * 3.5; // 2.5-6.0 (sharper filter)
        
        const noiseEnv = audioContext.createGain();
        noiseEnv.gain.setValueAtTime(0.001, nowWithDelay);
        noiseEnv.gain.linearRampToValueAtTime(0.4 * volume, nowWithDelay + 0.0005);
        noiseEnv.gain.exponentialRampToValueAtTime(0.001, nowWithDelay + 0.03);
        
        // Create merger for this layer
        const layerMerger = audioContext.createChannelMerger(2);
        
        // Connect pop oscillators with slight stereo spread
        const panner1 = audioContext.createStereoPanner();
        const panner2 = audioContext.createStereoPanner();
        panner1.pan.value = -0.3 + Math.random() * 0.6;
        panner2.pan.value = -0.3 + Math.random() * 0.6;
        
        popOsc1.connect(popEnv).connect(panner1).connect(layerMerger, 0, 0);
        popOsc2.connect(popEnv).connect(panner2).connect(layerMerger, 0, 1);
        
        // Connect noise with stereo spread
        const noisePanner = audioContext.createStereoPanner();
        noisePanner.pan.value = -0.2 + Math.random() * 0.4;
        
        noise.buffer = noiseBuffer;
        noise.loop = false;
        noise.connect(noiseFilter)
             .connect(noiseEnv)
             .connect(noisePanner)
             .connect(layerMerger, 0, 0);
        
        // Start all sound sources
        noise.start(nowWithDelay);
        popOsc1.start(nowWithDelay);
        popOsc2.start(nowWithDelay);
        
        // Stop sound sources after they're done
        const stopTime = nowWithDelay + 0.15;
        noise.stop(stopTime);
        popOsc1.stop(stopTime);
        popOsc2.stop(stopTime);
        
        return layerMerger;
        
        // Stop all sound sources
        noise.stop(now + 0.1);
        popOsc1.stop(now + 0.12);
        popOsc2.stop(now + 0.12);
        
        // Clean up
        setTimeout(() => {
            noise.disconnect();
            popOsc1.disconnect();
            popOsc2.disconnect();
            popEnv.disconnect();
            noiseFilter.disconnect();
            noiseEnv.disconnect();
            merger.disconnect();
        }, 200);
    }
    
    let popped = 0;
    
    // Create a new bubble sheet
    function createBubbleSheet() {
        bubbleWrap.innerHTML = '';
        popped = 0;
        poppedCount.textContent = '0';
        
        // Calculate available width and bubble size
        const containerWidth = bubbleWrap.clientWidth;
        const gap = 10; // gap between bubbles
        const bubblesPerRow = 10;
        const bubbleSize = Math.min(60, (containerWidth - (gap * (bubblesPerRow - 1))) / bubblesPerRow);
        
        // Create 100 bubbles (10x10 grid)
        for (let i = 0; i < 100; i++) {
            const bubble = document.createElement('div');
            bubble.className = 'bubble';
            bubble.dataset.index = i;
            
            // Set consistent size based on container
            bubble.style.width = `${bubbleSize}px`;
            bubble.style.height = `${bubbleSize}px`;
            
            // Random color variation
            const hue = 220 + Math.floor(Math.random() * 40) - 20; // Blue-ish colors
            const saturation = 70 + Math.floor(Math.random() * 20);
            const lightness = 50 + Math.floor(Math.random() * 20);
            bubble.style.backgroundColor = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
            
            // Add click/touch event
            bubble.addEventListener('mousedown', popBubble);
            bubble.addEventListener('touchstart', popBubble, { passive: true });
            
            bubbleWrap.appendChild(bubble);
        }
    }
    
    // Pop a bubble
    function popBubble(e) {
        e.preventDefault();
        const bubble = e.currentTarget;
        
        if (bubble.classList.contains('popped')) return;
        
        // Add popped class
        bubble.classList.add('popped');
        
        // Play click sound
        playClickSound();
        
        // Update counter
        popped++;
        poppedCount.textContent = popped;
        
        // Add pop animation
        bubble.style.animation = 'pop 0.2s ease-out';
        
        // Remove animation after it completes
        setTimeout(() => {
            bubble.style.animation = '';
        }, 200);
    }
    
    // Event listeners
    resetBtn.addEventListener('click', createBubbleSheet);
    newSheetBtn.addEventListener('click', createBubbleSheet);
    
    // Initialize
    createBubbleSheet();
    
    // Preload sounds
    popSounds.forEach(sound => {
        sound.load();
    });
});
</script>
{% endblock %}
